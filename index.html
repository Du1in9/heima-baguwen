<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; --title-bar-height: 20px; }
.mac-os-11 { --title-bar-height: 28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
h1, h2, h3, h4, h5 { white-space: pre-wrap; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
thead, tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
svg { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; border-color: transparent !important; padding-top: 0px !important; padding-bottom: 0px !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  #write > p:nth-child(1) { margin-top: 0px; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
  figure { overflow-x: visible; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.reversefootnote { font-family: ui-monospace, sans-serif; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex: 2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; overflow-wrap: anywhere; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }
mjx-container { break-inside: avoid; }
.md-alert.md-alert-note { border-left-color: rgb(9, 105, 218); }
.md-alert.md-alert-important { border-left-color: rgb(130, 80, 223); }
.md-alert.md-alert-warning { border-left-color: rgb(154, 103, 0); }
.md-alert.md-alert-tip { border-left-color: rgb(31, 136, 61); }
.md-alert.md-alert-caution { border-left-color: rgb(207, 34, 46); }
.md-alert { padding: 0px 1em; margin-bottom: 16px; color: inherit; border-left: 0.25em solid rgb(0, 0, 0); }
.md-alert-text-note { color: rgb(9, 105, 218); }
.md-alert-text-important { color: rgb(130, 80, 223); }
.md-alert-text-warning { color: rgb(154, 103, 0); }
.md-alert-text-tip { color: rgb(31, 136, 61); }
.md-alert-text-caution { color: rgb(207, 34, 46); }
.md-alert-text { font-size: 0.9rem; font-weight: 700; }
.md-alert-text svg { fill: currentcolor; position: relative; top: 0.125em; margin-right: 1ch; overflow: visible; }
.md-alert-text-container::after { content: attr(data-text); text-transform: capitalize; pointer-events: none; margin-right: 1ch; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow: auto hidden; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; outline: 0px; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: auto hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 10px; z-index: 3; overflow-y: hidden; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; overflow-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { overflow-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; inset: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
span.cm-underlined { text-decoration: underline; }
span.cm-strikethrough { text-decoration: line-through; }
.cm-tw-syntaxerror { color: rgb(255, 255, 255); background-color: rgb(153, 0, 0); }
.cm-tw-deleted { text-decoration: line-through; }
.cm-tw-header5 { font-weight: 700; }
.cm-tw-listitem:first-child { padding-left: 10px; }
.cm-tw-box { border-style: solid; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px; border-color: inherit; border-top-width: 0px !important; }
.cm-tw-underline { text-decoration: underline; }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

/* open-sans-regular - latin-ext_latin */
  /* open-sans-italic - latin-ext_latin */
    /* open-sans-700 - latin-ext_latin */
    /* open-sans-700italic - latin-ext_latin */
  html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
}

body {
    font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

/*@media print {
    .typora-export h1,
    .typora-export h2 {
        border-bottom: none;
        padding-bottom: initial;
    }

    .typora-export h1::after,
    .typora-export h2::after {
        content: "";
        display: block;
        height: 100px;
        margin-top: -96px;
        border-top: 1px solid #eee;
    }
}*/

h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table th:first-child,
table td:first-child {
    margin-top: 0;
}
table th:last-child,
table td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    pre {
        page-break-inside: avoid;
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.mac-os #write{
    caret-color: AccentColor;
}

.md-lang {
    color: #b4654d;
}

/*.html-for-mac {
    --item-hover-bg-color: #E6F0FE;
}*/

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
    opacity: 0.4;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}

.menu-item-container a.menu-style-btn {
    background-color: #f5f8fa;
    background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); 
}



</style><title>八股文-黑马</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><h1 id='第-1-章---准备篇'><span>第 1 章 - 准备篇</span></h1><h2 id='11-企业的筛选流程'><span>1.1 企业的筛选流程</span></h2><ol start='' ><li><p><span>HR 简历筛选</span></p><ul><li><p><span>学历、院校、经验、年龄、跳槽频率 …</span></p></li></ul></li><li><p><span>部门负责人筛选</span></p><ul><li><p><span>符合当前项目的技术栈</span></p></li><li><p><span>符合业务条件（银行、电商、物流）</span></p></li><li><p><span>额外加分项：</span></p><ul><li><p><span>有高可用高并发经验优先</span></p></li><li><p><span>熟悉基于公有云的开发经验</span></p></li><li><p><span>有团队管理经验 ...</span></p></li></ul></li></ul></li></ol><h2 id='12-简历的注意事项'><span>1.2 简历的注意事项</span></h2><ol start='' ><li><p><span>简历整体结构</span></p><p><span>基本信息、教育背景、求职意向、工作经历、</span><strong><span>职业技能</span></strong><span>、</span><strong><span>项目经历</span></strong><span>、个人优势、个人荣誉</span></p></li><li><p><span>职业技能</span></p><ul><li><p><span>放到简历的黄金位置（HR 刷选简历的重要参考）</span></p></li><li><p><span>基本准则：写在简历上的必须能聊，不然就别写</span></p></li><li><p><span>参考公式：职业技能 = 必要技术 + 其他技术</span></p></li><li><p><span>针对性的引导面试官（让他问一些你想让他问的）</span></p><ul><li><p><span>1-2年: (springboot + ssm + redis +数据库 ) + (2-3) 技术(微服务、ES、MQ、源码、高并发、jvm、技术选型、设计能力…）</span></p></li><li><p><span>3-5年: (springboot + ssm + redis +数据库) + (3-4) 技术(微服务、ES , MQ、源码、高并发、jvm、技术选型、设计能力…）</span></p></li><li><p><span>5+年: (springboot + ssm + redis +数据库) + (5+) 技术(微服务、ES 、MQ 、源码、高并发、jvm、技术选型、设计能力…）</span></p></li></ul></li></ul></li></ol><p><img src="baguwen\7162039.png" referrerpolicy="no-referrer" alt="7162039"></p><ol start='3' ><li><p><span>项目经历</span></p><ul><li><p><span>项目个数以自己的工作经历为准，时间比较久的可以只写标题或不写（面试官一般也不问）</span></p></li><li><p><span>项目要体现业务深度或技术深度</span></p></li><li><p><span>有没有主导设计过 xx 模块开发（0-1 或 1-2）</span></p></li><li><p><span>尽可能展示指标数据（如：达到了多少 QPS、达到了多少的数据量）</span></p></li></ul></li></ol><p><img src="baguwen\7162043.png" referrerpolicy="no-referrer" alt="7162043"></p><h2 id='13-适合应届生的练手项目'><span>1.3 适合应届生的练手项目</span></h2><ol start='' ><li><p><span>如何找到合适的练手项目</span></p><ul><li><p><span>Gitee 或 Github 搜索开源项目，B 站黑马程序员项目课程</span></p><ul><li><p><span>搜索比较感兴趣的技术点或者业务点</span></p></li><li><p><span>本地快速运行起来，debug 跟踪代码的逻辑</span></p></li><li><p><span>梳理完业务之后，自己能否独立完成</span></p></li><li><p><span>找到一、二点深度挖掘，多方位参考</span></p></li></ul></li></ul></li><li><p><span>如何深入学习项目</span></p><ul><li><p><span>技术选型：通用模块，可以嵌套到大部分项目中</span></p><ul><li><p><span>权限认证、文件服务、日志、搜索、秒杀、支付、缓存、Saas、订单、优惠券、CMS、报表 ...</span></p></li></ul></li><li><p><span>学习方式：多方位参考深入挖掘业务和技术</span></p></li><li><p><span>学习目标：增加简历的项目模块业务深度、技术含金量、真实度。例如，权限认证：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="sh"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="sh"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># 1. 功能实现 (权限认证)</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">业务功能实现：用户名密码登录、 二维码登录、手机短信登录、用户、角色、权限管理和分配</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">技术方案支撑：RBAC 模型、Spring Security 或 Apache Shiro </span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># 2. 常见的问题 </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">token 刷新问题、加密、解密、XSS 防跨站攻击</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># 3. 权限系统设计 </span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">可扩展性、高可用性、通用性</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 161px;"></div><div class="CodeMirror-gutters" style="display: none; height: 161px;"></div></div></div></pre></li></ul></li></ol><h2 id='14-java-程序员的面试过程'><span>1.4 Java 程序员的面试过程</span></h2><ol start='' ><li><p><span>面试形式</span></p><p><span>企业在招聘的时候，不同的公司面试的轮次不太一样。</span></p><ul><li><p><span>单轮面试：只有技术面试（中小企业、创业型公式、外包）</span></p></li><li><p><span>多轮面试</span></p><ul><li><p><span>两轮：第一、二轮技术面（大部分公司）</span></p></li><li><p><span>三轮、N 轮（上市公司、大厂）</span></p></li></ul></li></ul><p><span>面试官角色：</span></p><ul><li><p><span>资深开发人员：技术最好，多数参与首轮面试（技术水平）</span></p></li><li><p><span>业务部门经理：技术一般，多数参与终面，可以决定你的薪资（思考能力，抗压能力）</span></p></li><li><p><span>HR：辅助业务部门考察候选人（性格、沟通能力、合作能力、学习能力）</span></p></li></ul></li><li><p><span>面试过程</span></p><p><span>整体讲解结构：总分结构表述。</span></p><p><img src="baguwen\7162141.png" referrerpolicy="no-referrer" alt="7162141"></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="SH"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="sh"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># 1. 自我介绍: 条理清晰</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">我叫什么，我的工作经历主要是分为了3个阶段。1.xxxx, <span class="cm-number">2</span>.xxxx, <span class="cm-number">3</span>.xxxx</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># 2. 项目介绍: 一定要提前准备+事后复盘</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">例：针对“主导设计文章发布审核、延时发布等技术方案的选型和实现。”</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">提问：审核什么内容？什么技术实现的审核？延时发布的技术是如何实现的，是 Redis，还是 RabbitMQ?</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;"></div><div class="CodeMirror-gutters" style="display: none; height: 115px;"></div></div></div></pre></li><li><p><span>如何准备面试</span></p><p><span>找出自己的不足，针对性的补强。</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="sh"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="sh"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># =&gt; 如果你想进中厂，就要做进大厂的准备。</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># =&gt; 如果你想找到月薪 1W+ 的工作，就需要做月薪 1W5+ 的准备。</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># =&gt; 如果你的目标就是找到工作，起码要做冲击中小厂的准备。</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># =&gt; 如果你的目标就是找个小公司混日子，大概率找不到工作。</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 92px;"></div><div class="CodeMirror-gutters" style="display: none; height: 92px;"></div></div></div></pre></li></ol><h1 id='第-2-章---框架篇'><span>第 2 章 - 框架篇</span></h1><h2 id='21-spring'><span>2.1 Spring</span></h2><h3 id='211-spring'><span>2.1.1 Spring</span></h3><h4 id='2111-spring-框架中的单例-bean-是线程安全的吗'><span>2.1.1.1 Spring 框架中的单例 bean 是线程安全的吗？</span></h4><ul><li><p><span>注解 </span><code>@Scope</code><span> 的默认值是 </span><code>singleton</code><span>，单例的。一般 bean 都是注入无状态的对象，没有线程安全问题。</span></p></li><li><p><span>但如果在 bean 中定义了可修改的成员变量，是线程不安全的，可以使用 </span><strong><span>多例</span></strong><span> 或者 </span><strong><span>加锁</span></strong><span> 来解决。</span></p><p><span>例如，如果多个线程同时访问和修改 Bean 的成员变量，可能会导致数据不一致或竞态条件。</span></p></li></ul><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="java"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">@Component</span><span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 1. 单例</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-keyword">class</span> <span class="cm-def">Counter</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">int</span> <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 可修改状态变量，线程不安全</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-keyword">final</span> <span class="cm-variable-3">int</span> <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;<span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 不可修改状态变量，线程安全</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable-3">void</span> <span class="cm-variable">increment</span>() {<span class="cm-variable">count</span><span class="cm-operator">++</span>;}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable-3">void</span> <span class="cm-variable">increment</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">count</span>) {<span class="cm-variable">count</span><span class="cm-operator">++</span>;}<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 无状态变量，线程安全</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 184px;"></div><div class="CodeMirror-gutters" style="display: none; height: 184px;"></div></div></div></pre><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="java"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">@Component</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">@Scope</span>(<span class="cm-string">"prototype"</span>)<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 2. 多例，线程安全</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-keyword">class</span> <span class="cm-def">Counter</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">int</span> <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-variable-3">void</span> <span class="cm-variable">increment</span>() {<span class="cm-variable">count</span><span class="cm-operator">++</span>;}</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 138px;"></div><div class="CodeMirror-gutters" style="display: none; height: 138px;"></div></div></div></pre><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="java"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-meta">@Component</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-keyword">class</span> <span class="cm-def">Counter</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">private</span> <span class="cm-variable-3">int</span> <span class="cm-variable">count</span> <span class="cm-operator">=</span> <span class="cm-number">0</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">public</span> <span class="cm-keyword">synchronized</span> <span class="cm-variable-3">void</span> <span class="cm-variable">increment</span>() {<span class="cm-variable">count</span><span class="cm-operator">++</span>;}<span class="cm-tab" role="presentation" cm-text="	"> </span><span class="cm-comment">// 3. 加锁，线程安全</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 115px;"></div><div class="CodeMirror-gutters" style="display: none; height: 115px;"></div></div></div></pre><h4 id='2112-什么是-aop你的项目中有没有使用到-aop'><span>2.1.1.2 什么是 AOP，你的项目中有没有使用到 AOP？</span></h4><p><span>AOP（面向切面编程）用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取模块复用，降低耦合。</span></p><ul><li><p><span>项目中的应用：记录操作 </span><strong><span>日志</span></strong><span>，缓存，spring 实现的 </span><strong><span>事务</span></strong><span> 等。</span></p></li><li><p><span>使用 AOP 中的环绕通知 + 切点表达式，通过环绕通知的参数获取请求方法的参数，保存到数据库。</span></p></li></ul><p>&nbsp;</p><h4 id='2113-spring-中的事务是如何实现的'><span>2.1.1.3 Spring 中的事务是如何实现的？</span></h4><p><span>通过 AOP 对方法前后进行拦截，在执行方法之前开启事务，在执行方法之后提交或回滚事务。</span></p><h4 id='2114-spring-中事务失效的场景有哪些'><span>2.1.1.4 Spring 中事务失效的场景有哪些？</span></h4><ol start='' ><li><p><span>忘了加 </span><strong><span>@Service</span></strong><span> 没被 Spring 管理</span></p></li><li><p><span>非事务方法 this 调用绕过 Spring 的 </span><strong><span>AOP</span></strong></p></li><li><p><span>事务方法没用 </span><strong><span>public</span></strong></p></li><li><p><span>事务 </span><strong><span>异常</span></strong><span> 被捕获了</span></p></li><li><p><span>事务 </span><strong><span>异常类型</span></strong><span> 不对</span></p></li><li><p><span>事务 </span><strong><span>传播行为</span></strong><span> 不对</span></p></li></ol><h4 id='2115-spring-的-bean-的生命周期'><span>2.1.1.5 Spring 的 bean 的生命周期？</span></h4><p><span>1.实例化： 给 Bean 分配内存空间（</span><code>加载</code><span>）；</span></p><p><span>2.设置属性： 进行 Bean 的注入和装配；（</span><code>BeanDefinition</code><span>）</span></p><p><span>3.初始化：</span></p><ul><li><p><span>执行各种通知（</span><code>AOP</code><span>）；</span></p></li><li><p><span>执行初始化的前置工作；</span></p></li><li><p><span>进行初始化工作（使用注解 </span><code>@PostConstruct</code><span> 初始化）；</span></p></li><li><p><span>执行初始化的后置工作；</span></p></li></ul><p><span>4.使用Bean</span></p><p><span>5.销毁Bean</span></p><p><img src="baguwen\8051721.png" alt="8051721" style="zoom: 45%;" /></p><h4 id='2116-spring-中的循环引用'><span>2.1.1.6 Spring 中的循环引用？</span></h4><p><span>循环引用就是两个或两个以上的 bean 互相持有对方，最终形成闭环。比如 A 依赖于 B，B依赖于A。</span></p><p><span>循环引用在 spring 允许存在，依据三级缓存已经解决了大部分的循环依赖。</span></p><ul><li><p><span>一级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的 bean 对象</span></p></li><li><p><span>二级缓存：缓存早期的 bean 对象（生命周期还没走完）</span></p></li><li><p><span>三级缓存：缓存的是 ObjectFactory，即对象工厂，用来创建某个对象的</span></p></li></ul><p><strong><span>构造方法出现了循环依赖怎么解决？</span></strong></p><ul><li><p><span>原因：由于 bean 的生命周期中构造函数第一个执行，spring 并不能解决构造函数的循环依赖问题。</span></p></li><li><p><span>解决方案：手动添加 </span><code>@Lazy</code><span> 进行懒加载，需要对象的时候再进行 bean 对象的创建。</span></p></li></ul><h3 id='212-spring-mvc'><span>2.1.2 Spring MVC</span></h3><h4 id='2121-spring-mvc-的执行流程'><span>2.1.2.1 Spring MVC 的执行流程？</span></h4><ol start='' ><li><p><span>用户发送出请求到前端控制器 </span><code>DispatcherServlet</code></p></li><li><p><code>DispatcherServlet</code><span> 收到请求调用处理器映射器 </span><code>HandlerMapping</code></p></li><li><p><code>HandlerMapping</code><span> 找到具体的处理器，生成处理器对象及拦截器返回给 </span><code>DispatcherServlet</code></p></li><li><p><code>DispatcherServlet</code><span> 调用处理器适配器 </span><code>HandlerAdapter</code></p></li><li><p><code>HandlerAdapter</code><span> 经过适配调用具体的处理器 </span><code>Handler/Controller</code></p></li><li><p><span>如果有注解 </span><code>@ResponseBody</code><span>，通过 </span><code>HttpMessageConverter</code><span> 返回 </span><code>JSON</code><span> 并响应</span></p></li></ol><p><img src="baguwen\8051757.png" referrerpolicy="no-referrer" alt="8051757"></p><h3 id='213-spring-boot'><span>2.1.3 Spring Boot</span></h3><h4 id='2131-spring-boot-的自动配置原理'><span>2.1.3.1 Spring Boot 的自动配置原理？</span></h4><ol start='' ><li><p><span>注解 </span><code>@SpringBootApplication</code><span> 封装了 </span><code>@SpringBootConfiguration</code><span>、</span><code>@EnableAutoConfiguration</code><span>、</span><code>@ComponentScan</code></p><p><span>作用分别是：上下文配置 + 自动配置 + 扫描指定包的组件。</span></p></li><li><p><span>其中 </span><code>@EnableAutoConfiguration</code><span> 是自动配置的核心注解，源码中注解 </span><code>@Import</code><span> 导入对应的配置选择器。</span></p><p><span>内部读取了该项目 classpath 路径下 </span><strong><span>META-INF/spring.factories</span></strong><span> 文件中所配置的 </span><strong><span>全类名</span></strong><span>。 </span></p></li><li><p><span>在这些配置类中所定义的 Bean 会根据条件注解的条件，来决定是否将其导入到 </span><strong><span>Spring 容器</span></strong><span> 中。</span></p><p><span>例如条件注解 @</span><code>ConditionalOnClass</code><span> ，会判断是否有对应的 class 文件，如果有则加载该类。</span></p></li></ol><p><img src="baguwen\8051810.png" alt="8051810" style="zoom: 45%;" /></p><h4 id='2132-springspring-mvcspring-boot-常见注解'><span>2.1.3.2 Spring、Spring MVC、Spring Boot 常见注解？</span></h4><figure class='table-figure'><table><thead><tr><th><strong><span>Spring</span></strong></th><th><strong><span>说明</span></strong></th></tr></thead><tbody><tr><td><span>@Component、@Controller、@Service、@Repository</span></td><td><span>使用在类上用于实例化 Bean</span></td></tr><tr><td><span>@Autowired</span></td><td><span>使用在字段上用于根据类型依赖注入</span></td></tr><tr><td><span>@Qualifier</span></td><td><span>结合 @Autowired 一起使用用于根据名称进行依赖注入</span></td></tr><tr><td><span>@Scope</span></td><td><span>标注 Bean 的作用范围</span></td></tr><tr><td><span>@Configuration</span></td><td><span>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</span></td></tr><tr><td><span>@ComponentScan</span></td><td><span>用于指定 Spring  在初始化容器时要扫描的包</span></td></tr><tr><td><span>@Bean</span></td><td><span>使用在方法上，标注将该方法的返回值存储到 Spring 容器中</span></td></tr><tr><td><span>@Import</span></td><td><span>使用 @Import 导入的类会被 Spring 加载到 IOC 容器中</span></td></tr><tr><td><span>@Aspect、@Before、@After、@Around、@Pointcut</span></td><td><span>用于切面编程（AOP）</span></td></tr></tbody></table></figure><figure class='table-figure'><table><thead><tr><th><strong><span>Spring MVC</span></strong></th><th><strong><span>说明</span></strong></th></tr></thead><tbody><tr><td><span>@RequestMapping</span></td><td><span>用于映射请求路径，可以定义在类上和方法上。用于类上，则表示类中的所有的方法都是以该地址作为父路径</span></td></tr><tr><td><span>@RequestBody</span></td><td><span>注解实现接收 http 请求的 json 数据，将 json 转换为 java 对象</span></td></tr><tr><td><span>@RequestParam</span></td><td><span>指定请求参数的名称</span></td></tr><tr><td><span>@PathViriable</span></td><td><span>从请求路径下中获取请求参数 </span><code>/user/{id}</code><span>，传递给方法的形式参数</span></td></tr><tr><td><span>@ResponseBody</span></td><td><span>注解实现将 controller 方法返回对象转化为 json 对象响应给客户端</span></td></tr><tr><td><span>@RequestHeader</span></td><td><span>获取指定的请求头数据</span></td></tr><tr><td><span>@RestController</span></td><td><span>@Controller + @ResponseBody</span></td></tr></tbody></table></figure><figure class='table-figure'><table><thead><tr><th><strong><span>Spring Boot</span></strong></th><th><strong><span>说明</span></strong></th></tr></thead><tbody><tr><td><span>@SpringBootConfiguration</span></td><td><span>组合了@Configuration 注解，实现配置文件的功能</span></td></tr><tr><td><span>@EnableAutoConfiguration</span></td><td><span>打开自动配置的功能，也可以关闭某个自动配置的选</span></td></tr><tr><td><span>@ComponentScan</span></td><td><span>Spring 组件扫描</span></td></tr></tbody></table></figure><h2 id='22-mybatis'><span>2.2 Mybatis</span></h2><h3 id='221-mybatis-的执行流程'><span>2.2.1 MyBatis 的执行流程？</span></h3><ol start='' ><li><p><span>读取配置文件 </span><code>mybatis-config.xml</code><span>，加载运行环境和映射文件</span></p></li><li><p><span>构造会话工厂 </span><code>SqlSessionFactory</code></p></li><li><p><span>会话工厂创建 </span><code>SqlSession</code><span> 对象</span></p></li><li><p><span>操作数据库的接口 </span><code>Executor</code><span> 执行器，同时负责查询缓存的维护</span></p></li><li><p><span>Executor 接口的执行方法中有一个 </span><code>MappedStatement</code><span> 类型的参数，封装了映射信息</span></p></li><li><p><span>输入参数映射，输出结果映射</span></p></li></ol><p><img src="baguwen\8051823.png" alt="8051823" style="zoom: 50%;" /></p><h3 id='222-mybatis-是否支持延迟加载'><span>2.2.2 Mybatis 是否支持延迟加载？</span></h3><p><span>延迟加载就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据。</span></p><ul><li><p><span>Mybatis 支持一对一关联对象和一对多关联集合对象的延迟加载</span></p></li><li><p><span>在配置文件中，可以配置 </span><code>lazyLoadingEnabled</code><span> 是否启用延迟加载，默认是关闭的</span></p></li></ul><p><strong><span>延迟加载的底层原理知道吗？</span></strong></p><ol start='' ><li><p><span>使用 CGLIB 创建目标对象的 </span><code>代理对象</code></p></li><li><p><span>当调用目标方法时，进入拦截器 </span><code>invoke方法</code><span>，发现目标方法是 null 值</span></p></li><li><p><span>于是查询数据，调用 </span><code>set方法</code><span> 设置属性值，再查询目标方法就有值了</span></p></li></ol><h3 id='223-mybatis-的一级二级缓存'><span>2.2.3 Mybatis 的一级、二级缓存？</span></h3><figure class='table-figure'><table><thead><tr><th>&nbsp;</th><th><span>一级缓存 (Local Cache)</span></th><th><span>二级缓存 (Second Level Cache)</span></th></tr></thead><tbody><tr><td><strong><span>作用范围</span></strong></td><td><span>单个 SQL Session</span></td><td><span>多个 SQL Session，跨 Session 共享</span></td></tr><tr><td><strong><span>存储机制</span></strong></td><td><code>PerpetualCache</code><span> 和 </span><code>HashMap</code></td><td><code>PerpetualCache</code><span> 和 </span><code>HashMap</code></td></tr><tr><td><strong><span>默认开启</span></strong></td><td><span>是</span></td><td><span>否</span></td></tr><tr><td><strong><span>清空时机</span></strong></td><td><span>Session 执行 flush 或 close 操作时清空</span></td><td><span>通常为 SQL 增删改操作后清空</span></td></tr><tr><td><strong><span>配置位置</span></strong></td><td><span>核心配置文件</span></td><td><span>Mapper 映射文件</span></td></tr></tbody></table></figure><p>&nbsp;</p><h1 id='第-3-章---微服务篇'><span>第 3 章 - 微服务篇</span></h1><h2 id='31-spring-cloud'><span>3.1 Spring Cloud</span></h2><h3 id='311-服务注册'><span>3.1.1 服务注册</span></h3><h4 id='3111-spring-cloud-5大组件有哪些'><span>3.1.1.1 Spring Cloud 5大组件有哪些？</span></h4><p><span>随着 SpringCloud Alibba 在国内兴起 , 我的项目中使用了一些阿里巴巴的组件： </span></p><ol start='' ><li><p><span>注册中心 / 配置中心：</span><code>Nacos</code></p></li><li><p><span>负载均衡：</span><code>Ribbon</code></p></li><li><p><span>服务调用：</span><code>Feign</code></p></li><li><p><span>服务保护：</span><code>sentinel</code></p></li><li><p><span>服务网关：</span><code>Gateway</code></p></li></ol><h4 id='3112-服务注册和发现是什么意思如何实现服务注册发现'><span>3.1.1.2 服务注册和发现是什么意思？如何实现服务注册发现？</span></h4><p><span>我们当时项目采用的 nacos 作为注册中心。服务注册发现流程：</span></p><ul><li><p><span>服务注册：服务提供者需要把自己的信息注册到 nacos ，由 nacos 来保存这些信息，比如服务名称、ip、端口等等</span></p></li><li><p><span>服务发现：消费者向 nacos 拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</span></p></li><li><p><span>服务监控：服务提供者会每隔 30 秒向 nacos 发送心跳，报告健康状态，如果 90 秒没接收到心跳，从 nacos 中剔除</span></p></li></ul><h3 id='312-负载均衡'><span>3.1.2 负载均衡</span></h3><h4 id='3121-你们项目负载均衡如何实现的-'><span>3.1.2.1 你们项目负载均衡如何实现的 ? </span></h4><p><span>主要使用了一个组件 Ribbon。我们在使用 feign 远程调用的过程中，底层的负载均衡使用了 ribbon。</span></p><h4 id='3122-ribbon-负载均衡策略有哪些-'><span>3.1.2.2 Ribbon 负载均衡策略有哪些 ? </span></h4><ol start='' ><li><p><code>RandomRule</code><span>：</span><strong><span>随机</span></strong><span> 选择一个可用的服务器</span></p></li><li><p><code>RoundRobinRule</code><span>：简单 </span><strong><span>轮询</span></strong><span> 服务列表来选择服务器</span></p></li><li><p><code>WeightedResponseTimeRule</code><span>：按照 </span><strong><span>权重</span></strong><span> 来选择服务器，响应时间越长，权重越小</span></p></li><li><p><code>ZoneAvoidanceRule</code><span>：</span><strong><span>区域</span></strong><span> 敏感策略，以区域可用的服务器为基础进行服务器的选择</span></p></li></ol><h4 id='3123-自定义负载均衡策略如何实现-'><span>3.1.2.3 自定义负载均衡策略如何实现 ? </span></h4><ol start='' ><li><p><span>创建类实现 </span><code>IRule</code><span> 接口，可以指定负载均衡策略（全局）</span></p></li><li><p><span>在客户端的配置文件中，可以指定某一个服务的负载均衡策略（局部）</span></p></li></ol><h3 id='313-服务雪崩'><span>3.1.3 服务雪崩</span></h3><ul><li><p><span>服务雪崩：一个服务失败，导致整条链路的服务都失败的情形</span></p></li><li><p><span>服务降级：服务自我保护的一种方式，确保服务不会崩溃，一般在实际开发中与 feign 接口整合，编写降级逻辑。</span></p></li><li><p><span>服务熔断：默认关闭，需要手动打开。如果检测到 10 秒内请求的失败率超过一半，就触发熔断机制。</span></p><p><span>之后每隔 5 秒重新尝试请求，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制。</span></p></li></ul><h3 id='314-服务监控'><span>3.1.4 服务监控</span></h3><p><span>我们项目中是采用 skywalking 进行监控的。</span></p><ol start='' ><li><p><span>skywalking 可以监控接口、服务、物理实例的状态。特别是在压测的时候，可以看到哪些服务和接口比较慢，进行分析和优化。</span></p></li><li><p><span>skywalking 可以设置告警规则。特别是在项目上线以后，如果报错可以给负责人发短信，第一时间知道 bug 情况，进行修复。</span></p></li></ol><h2 id='32-业务相关'><span>3.2 业务相关</span></h2><h3 id='321-项目中有没有做过限流怎么做的'><span>3.2.1 项目中有没有做过限流？怎么做的？</span></h3><ol start='' ><li><p><span>先介绍业务：我们当时有一个活动，到了假期就会抢购优惠券，QPS 最高可以达到 2000，平时 10-50 之间。</span></p></li><li><p><span>nginx 限流：使用漏桶算法，让请求以固定的速率处理请求，应对突发流量控制并发数，限制单个 ip 的链接数和并发总数。</span></p></li><li><p><span>网关限流：使用令牌桶算法，gateway 中支持局部过滤器。根据 ip 或路径进行限流，设置每秒填充平均速率和令牌桶总容量。</span></p></li></ol><h3 id='322-什么是-cap-和-base'><span>3.2.2 什么是 CAP 和 BASE？</span></h3><ol start='' ><li><p><span>CAP 定理：一致性、可用性、分区容错性。</span></p><ul><li><p><span>分布式系统节点通过网络连接，一定会出现分区问题（P）</span></p></li><li><p><span>当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足</span></p></li></ul></li><li><p><span>BASE 理论：基本可用、软状态、最终一致。</span></p></li></ol><h3 id='323-分布式事务的解决方案'><span>3.2.3 分布式事务的解决方案？</span></h3><p><span>简历上写的微服务，只要是发生了多个服务之间的写操作，都需要进行分布式事务控制。</span></p><ul><li><p><span>解决思想：</span></p><ul><li><p><span>强一致思想（CP）：各分支事务执行完不要提交，等待彼此结果，而后统一提交或回滚</span></p></li><li><p><span>最终一致思想（AP）：各分支事务分别执行并提交，如果不一致，再想办法恢复数据。（√）</span></p></li></ul></li><li><p><span>解决方案：MQ 实现分布式事务，服务写数据的时候，在同一个事务内发送消息到另外一个事务。异步，性能好。</span></p></li></ul><h3 id='324-分布式服务的接口幂等性如何设计'><span>3.2.4 分布式服务的接口幂等性如何设计？</span></h3><p><span>幂等：多次调用方法或接口不会改变业务状态，重复和单次调用的结果一致。（查删幂等，增改不幂等）</span></p><ul><li><p><span>如果是新增数据，使用数据库的唯一索引。</span></p></li><li><p><span>如果是新增或修改数据，使用分布式锁，性能较低；② 使用 token+redis，性能较好：</span></p><ul><li><p><span>第一次请求，生成唯一的 token，存入 redis 并返回前端</span></p></li><li><p><span>第二次请求，携带之前的 token，到 redis 进行验证。如果存在，则执行业务并清空；如果不存在，则不执行业务。</span></p></li></ul></li></ul><h3 id='325-分布式任务调度'><span>3.2.5 分布式任务调度</span></h3><h4 id='3251-xxl-job-路由策略有哪些'><span>3.2.5.1 xxl-job 路由策略有哪些？</span></h4><p><span>xxl-job 提供了很多的路由策略，我们平时用的较多是：轮询、故障转移、分片广播。</span></p><h4 id='3252-xxl-job-任务执行失败怎么解决'><span>3.2.5.2 xxl-job 任务执行失败怎么解决？</span></h4><ol start='' ><li><p><span>路由策略选择故障转移，使用健康的实例来执行任务</span></p></li><li><p><span>设置重试次数</span></p></li><li><p><span>查看日志 + 邮件告警来通知相关负责人解决</span></p></li></ol><h4 id='3253-如果有大数据量的任务同时都需要执行怎么解决'><span>3.2.5.3 如果有大数据量的任务同时都需要执行，怎么解决？</span></h4><ul><li><p><span>路由策略选择分片广播，让多个实例一块去执行，即部署集群</span></p></li><li><p><span>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</span></p></li></ul><p>&nbsp;</p><h1 id='第-4-章---消息中间件篇'><span>第 4 章 - 消息中间件篇</span></h1><h2 id='41-rabbitmq'><span>4.1 RabbitMQ</span></h2><h3 id='411-rabbitmq-如何保证消息不丢失'><span>4.1.1 RabbitMQ 如何保证消息不丢失</span></h3><ol start='' ><li><p><span>开启 </span><code>生产者确认机制</code><span>，确保生产者的消息 </span><strong><span>ack</span></strong><span> 能到达队列。</span></p></li><li><p><span>开启 </span><code>持久化功能</code><span>，确保消息未消费前在 </span><strong><span>队列中</span></strong><span> 不会丢失</span></p></li><li><p><span>开启 </span><code>消费者确认机制</code><span>为 auto，由 </span><strong><span>spring</span></strong><span> 确认消息处理成功后完成 ack。</span></p></li><li><p><span>开启 </span><code>消费者失败重试机制</code><span>，多次失败后将消息投递到 </span><strong><span>异常交换机</span></strong><span>，交由人工处理。</span></p></li></ol><p><img src="baguwen\8052215.png" alt="8052215" style="zoom: 50%;" /></p><h3 id='412-rabbitmq-消息的重复消费问题如何解决的'><span>4.1.2 RabbitMQ 消息的重复消费问题如何解决的？</span></h3><ul><li><p><span>每条消息设置一个唯一的标识 id</span></p></li><li><p><span>幂等方案：分布式锁、数据库锁（悲观锁、乐观锁） </span></p></li></ul><p><img src="baguwen\8052219.png" alt="8052219" style="zoom: 50%;" /></p><h3 id='413-rabbitmq-延迟队列有了解过嘛'><span>4.1.3 RabbitMQ 延迟队列有了解过嘛？</span></h3><p><span>我们当时一个（超时订单、限时优惠、定时发布）业务使用到了延迟队列，是用死信交换机和 TTL 实现的。</span></p><ul><li><p><span>如果消息超时未消费（或拒绝被消费，或队列满了）就会变成死信。</span></p></li><li><p><span>通过延迟队列插件实现延迟队列：</span></p><ul><li><p><span>声明一个交换机 dl.direct，添加属性 </span><code>delayed</code><span> 为 true。</span></p></li><li><p><span>发送消息时添加 x-delay 头，值为超时时间 </span><code>ttl</code><span>。</span></p></li></ul></li></ul><p><img src="baguwen\8052224.png" alt="8052224" style="zoom:50%;" /></p><h3 id='414-rabbitmq-消息堆积如何解决'><span>4.1.4 RabbitMQ 消息堆积如何解决？</span></h3><ol start='' ><li><p><span>增加更多 </span><strong><span>消费者</span></strong><span>，提高消费速度。</span></p></li><li><p><span>在消费者内开启 </span><strong><span>线程池</span></strong><span> 加快消息处理速度。</span></p></li><li><p><span>扩大队列容积，提高堆积上限，采用 </span><strong><span>惰性队列</span></strong><span>：</span></p><ul><li><p><span>在声明队列的时候可以设置属性 </span><code>x-queue-mode</code><span> 为 lazy。</span></p></li><li><p><span>基于磁盘存储，消息上限高。但受限于磁盘 IO，时效性会降低。</span></p></li></ul></li></ol><h3 id='415-rabbitmq-的高可用机制有了解过嘛'><span>4.1.5 RabbitMQ 的高可用机制有了解过嘛？</span></h3><p><span>在生产环境下，我们当时采用的镜像模式搭建的集群，共有 3 个节点。</span></p><ul><li><p><span>可以采用镜像队列，结构是一主多从。所有操作都是主节点完成，然后同步给镜像节点。</span></p></li><li><p><span>主宕机后，镜像节点会替代成新的主。但如果在主从同步完成前，主就已经宕机，可能出现数据丢失。</span></p></li></ul><p><strong><span>那出现丢数据怎么解决呢？</span></strong></p><ul><li><p><span>那就采用仲裁队列，与镜像队列一样，都是主从模式。支持主从数据同步，强一致。</span></p></li><li><p><span>使用起来也非常简单，不需要额外的配置，在声明队列的时候指定这个是仲裁队列即可。</span></p></li></ul><h2 id='42-kafka'><span>4.2 Kafka</span></h2><h3 id='421-消息不丢失'><span>4.2.1 消息不丢失</span></h3><h4 id='kafka-是如何保证消息不丢失的'><span>Kafka 是如何保证消息不丢失的？</span></h4><ol start='' ><li><p><span>防止生产者发送消息到 Brocker 丢失：</span></p><ul><li><p><span>设置异步发送，发送失败使用回调进行记录或重发</span></p></li></ul></li><li><p><span>防止消息在 Brocker 中存储丢失：</span></p><ul><li><p><span>发送确认 acks，让所有的副本都参与保存数据后确认</span></p></li></ul></li><li><p><span>防止消费者从 Brocker 接收消息丢失</span></p><ul><li><p><span>关闭自动提交偏移量，开启手动提交偏移量，最好是同步 + 异步提交</span></p></li></ul></li></ol><h3 id='422-消息重复消费'><span>4.2.2 消息重复消费</span></h3><h4 id='4221-kafka-消息重复消费问题是如何解决的'><span>4.2.2.1 Kafka 消息重复消费问题是如何解决的？</span></h4><ul><li><p><span>关闭自动提交偏移量，开启手动提交偏移量，最好是同步 + 异步提交</span></p></li><li><p><span>幂等方案</span></p></li></ul><h4 id='4222-kafka-是如何保证消费的顺序性的'><span>4.2.2.2 Kafka 是如何保证消费的顺序性的？</span></h4><p><span>一个 topic 的数据可能存储在不同的分区，每个分区都有一个按顺序存储的偏移量，如果消费者关联了多个分区就不能保证顺序性。</span></p><p><span>解决方案：① 发送消息时指定分区号；② 发送消息时按照相同的业务设置相同的 key。</span></p><h3 id='423-高可用机制'><span>4.2.3 高可用机制</span></h3><h4 id='4231-kafka-的高可用机制有了解过嘛'><span>4.2.3.1 Kafka 的高可用机制有了解过嘛？</span></h4><ol start='' ><li><p><span>集群：</span></p><ul><li><p><span>一个 kafka 集群由多个 broker 实例组成，即使某一台宕机，也不耽误其他 broker 继续对外提供服务</span></p></li></ul></li><li><p><span>复制机制：</span></p><ul><li><p><span>一个 topic 有多个分区，每个分区有多个副本。有一个 leader，其余是 follower，副本存储在不同的 broker 中。</span></p></li><li><p><span>所有分区副本的内容是都是相同的，如果 leader 发生故障，会自动将其中一个 follower 提升为 leader，保证了高可用性。</span></p></li></ul></li></ol><h4 id='4232-解释一下复制机制中的-isr'><span>4.2.3.2 解释一下复制机制中的 ISR？</span></h4><p><span>分区副本分为了两类：一个是 ISR 副本，与 leader 同步保存数据。另外一个是普通副本，与 leader 异步保存数据。</span></p><p><span>当 leader 挂掉之后，会优先从 ISR 副本列表中选取一个作为 leader。</span></p><h3 id='424-高性能设计'><span>4.2.4 高性能设计</span></h3><h4 id='kafka-中实现高性能的设计有了解过嘛'><span>Kafka 中实现高性能的设计有了解过嘛？</span></h4><ul><li><p><strong><span>消息分区</span></strong><span>：不受单台服务器的限制，可以不受限的处理更多的数据</span></p></li><li><p><strong><span>顺序读写</span></strong><span>：磁盘顺序读写，提升读写效率</span></p></li><li><p><strong><span>页缓存</span></strong><span>：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</span></p></li><li><p><strong><span>零拷贝</span></strong><span>：减少上下文切换及数据拷贝</span></p></li><li><p><span>消息压缩：减少磁盘IO和网络IO</span></p></li><li><p><span>分批发送：将消息打包批量发送，减少网络开销</span></p></li></ul><h3 id='425-数据存储和清理'><span>4.2.5 数据存储和清理</span></h3><h4 id='kafka-数据清理机制了解过嘛'><span>Kafka 数据清理机制了解过嘛？</span></h4><ul><li><p><span>Kafka 存储结构</span></p><ul><li><p><span>Kafka 中 topic 的数据存储在分区上，如果文件过大会分段存储 segment</span></p></li><li><p><span>每个分段都在磁盘上以索引 (.index) 和日志文件 (.log) 的形式存储 </span></p></li><li><p><span>分段的好处：第一，能够减少单个文件的大小，查找数据方便；第二，方便进行日志清理。</span></p></li></ul></li><li><p><span>日志的清理策略：</span></p><ol start='' ><li><p><span>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</span></p></li><li><p><span>根据 topic 存储的数据大小，当 topic 所占的日志文件大小大于一定的阈值，则开始删除最久的消息。（默认关闭）</span></p></li></ol></li></ul><p>&nbsp;</p><h1 id='第-5-章---集合篇'><span>第 5 章 - 集合篇</span></h1><h2 id='51-集合基础'><span>5.1 集合基础</span></h2><h3 id='511-算法复杂度'><span>5.1.1 算法复杂度</span></h3><ol start='' ><li><p><strong><span>时间复杂度：</span></strong></p><ul><li><p><span>表示算法的执行时间与数据规模之间的增长关系。常见的时间复杂度：</span><code>O(1)、O(logn)、O(n)、O(n^2)、O(n!)</code><span>。</span></p></li></ul></li><li><p><strong><span>空间复杂度：</span></strong></p><ul><li><p><span>表示算法的存储空间与数据规模之间的增长关系。常见的空间复杂度：</span><code>O(1)、O(n)、O(n ^2)</code><span>。</span></p></li></ul></li></ol><h3 id='512-list-相关'><span>5.1.2 List 相关</span></h3><h4 id='5121-数组'><span>5.1.2.1 数组</span></h4><ol start='' ><li><p><strong><span>数组的下标为什么从 0 开始？</span></strong></p><ul><li><p><span>因为寻址公式是：</span><code>baseAddress + i * dataTypeSize</code><span>，这样计算下标的内存地址效率较高。</span></p></li></ul></li><li><p><strong><span>数组查找的时间复杂度？</span></strong></p><ul><li><p><span>已知下标，查找元素的时间复杂度是 </span><code>O(1)</code></p></li><li><p><span>未知下标，查找元素的时间复杂度是 </span><code>O(n)</code></p></li><li><p><span>未知下标但排序，二分查找元素的时间复杂度是 </span><code>O(logn)</code></p></li></ul></li><li><p><strong><span>数组插入和删除时间复杂度？</span></strong></p><ul><li><p><span>为了保证数组的内存连续性，需要挪动数组元素，平均时间复杂度为 </span><code>O(n)</code></p></li></ul></li></ol><h4 id='5122-链表'><span>5.1.2.2 链表</span></h4><ol start='' ><li><p><strong><span>单向链表和双向链表的区别是什么？</span></strong></p><ul><li><p><span>单向链表只有一个方向，结点只有一个后继指针 next。</span></p></li><li><p><span>双向链表支持两个方向，结点不止有一个后继指针 next，还有一个前驱指针 prev。</span></p></li></ul></li><li><p><strong><span>链表操作数据的时间复杂度是多少？</span></strong></p><ul><li><p><span>单向链表的增删查：头节点 O(1)，其他节点 O(n)。</span></p></li><li><p><span>双向链表的增删查：头尾节点 O(1)，其他节点 O(n)，给定节点 O(1)。</span></p></li></ul></li></ol><h3 id='513-hashmap-相关'><span>5.1.3 HashMap 相关</span></h3><h4 id='5131-二叉树'><span>5.1.3.1 二叉树</span></h4><p><strong><span>什么是二叉树？</span></strong></p><ul><li><p><span>每个节点最多有两个 “叉”，分别是左子节点和右子节点。</span></p></li><li><p><span>不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。</span></p></li><li><p><span>二叉树每个节点的左子树和右子树也分别满足二叉树的定义。</span></p></li></ul><p><strong><span>什么是二叉搜索树？</span></strong></p><ul><li><p><span>二叉搜索树（Binary Search Tree，BST）又名二叉查找树，有序二叉树。</span></p></li><li><p><span>左子树中的每个节点的值都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</span></p></li><li><p><span>通常情况下时间复杂度为 </span><code>O(logn)</code><span>。</span></p></li></ul><p><strong><span>什么是红黑树？</span></strong></p><ul><li><p><span>红黑树（Red Black Tree）是一种自平衡的二叉搜索树。</span></p></li><li><p><span>时间复杂度：查找、添加、删除都是 </span><code>O(logn)</code><span>。</span></p></li></ul><h4 id='5132-散列表'><span>5.1.3.2 散列表</span></h4><p><strong><span>什么是散列表？</span></strong></p><ul><li><p><span>散列表又称哈希表，由数组演化而来。根据 key 访问内存下标 value 的数据结构。</span></p></li></ul><p><strong><span>什么是散列冲突？</span></strong></p><ul><li><p><span>散列冲突又称哈希冲突，哈希碰撞。指多个 key 映射到同一个数组下标 value。</span></p></li></ul><p><strong><span>什么是拉链法？</span></strong></p><ul><li><p><span>数组的每个下标位置称为桶，每个桶对应一条链表。冲突后的元素都放到对应的链表或红黑树中。</span></p></li></ul><h2 id='52-集合面试题'><span>5.2 集合面试题</span></h2><h3 id='521-常见集合类'><span>5.2.1 常见集合类</span></h3><p><img src="baguwen\8061926.png" referrerpolicy="no-referrer" alt="8061926"></p><ul><li><p><span>Vector：动态数组。ArrayList：动态数组。LinkedList：双向链表。HashSet：哈希表。TreeSet：红黑树。</span></p></li><li><p><span>Hashtable：哈希表。HashMap：哈希表。ConcurrentHashMap：哈希表。TreeMap：红黑树。</span></p></li></ul><h3 id='522-list-相关'><span>5.2.2 List 相关</span></h3><h4 id='5221-arraylist-底层原理'><span>5.2.2.1 ArrayList 底层原理？</span></h4><ul><li><p><span>数据结构：ArrayList 底层是用动态数组实现的。</span></p></li><li><p><span>初始容量：ArrayList 初始容量为 0，当第一次添加数据的时候才会初始化容量为 10。</span></p></li><li><p><span>扩容逻辑：ArrayList 在进行扩容的时候是原来容量的 1.5 倍，每次扩容都需要拷贝数组。</span></p></li><li><p><span>添加逻辑：</span></p><ol start='' ><li><p><span>确保数组已使用长度 size + 1 后足够存下一个数据。</span></p></li><li><p><span>如果数组已使用长度 size + 1 后大于当前数组长度，则调用 grow 方法扩容。</span></p></li><li><p><span>确保新元素有地方存储之后，将新元素添加到位于 size 的位置上，返回 true。</span></p></li></ol></li></ul><h4 id='5222-arraylist-listnew-arraylist10-中的-list-扩容几次'><span>5.2.2.2 ArrayList list=new ArrayList(10) 中的 List 扩容几次？</span></h4><p><span>该语句只是声明和实例了一个 ArrayList，指定容量为 10，未进行扩容。参考源码：</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="java"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-keyword">public</span> <span class="cm-variable">ArrayList</span>(<span class="cm-variable-3">int</span> <span class="cm-variable">initialCapacity</span>) {</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp;<span class="cm-keyword">if</span> (<span class="cm-variable">initialCapacity</span> <span class="cm-operator">&gt;</span> <span class="cm-number">0</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">this</span>.<span class="cm-variable">elementData</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable-3">Object</span>[<span class="cm-variable">initialCapacity</span>];</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  } <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> (<span class="cm-variable">initialCapacity</span> <span class="cm-operator">==</span> <span class="cm-number">0</span>) {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">this</span>.<span class="cm-variable">elementData</span> <span class="cm-operator">=</span> <span class="cm-variable">EMPTY_ELEMENTDATA</span>;</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  } <span class="cm-keyword">else</span> {</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-keyword">throw</span> <span class="cm-keyword">new</span> <span class="cm-variable">IllegalArgumentException</span>(<span class="cm-string">"Illegal Capacity: "</span> <span class="cm-operator">+</span> <span class="cm-variable">initialCapacity</span>);</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"> &nbsp;  }</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">}</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 207px;"></div><div class="CodeMirror-gutters" style="display: none; height: 207px;"></div></div></div></pre><h4 id='5223-如何实现数组和-list-之间的转换'><span>5.2.2.3 如何实现数组和 List 之间的转换？</span></h4><ul><li><p><span>数组转 List，使用 Arrays 工具类的 </span><code>asList</code><span> 方法。</span></p><p><span>用 </span><code>asList</code><span> 转 list 后，如果修改了数组，list 会受影响。因为底层构造器仅把集合进行了包装，指向的是同一个内存地址。</span></p></li><li><p><span>List 转数组，使用 List 工具类的 </span><code>toArray</code><span> 方法。</span></p><p><span>用 </span><code>toArray</code><span> 转数组后，如果修改了 list，数组不会影响。因为底层进行了数组的拷贝，跟原来的元素没啥关系了。</span></p></li></ul><h4 id='5224-arraylist-和-linkedlist-的区别是什么'><span>5.2.2.4 ArrayList 和 LinkedList 的区别是什么？</span></h4><ol start='' ><li><p><span>底层数据结构：</span></p><ul><li><p><span>ArrayList 由动态数组的数据结构实现</span></p></li><li><p><span>LinkedList 由双向链表的数据结构实现</span></p></li></ul></li><li><p><span>效率：</span></p><ul><li><p><span>ArrayList 已知下标查 O(1)，未知下标查 O(n)，尾增删 O(1)，其他 O(n)。</span></p></li><li><p><span>LinkedList 头尾节点增删查 O(1)，其他节点 O(n)，给定节点 O(1)。</span></p></li></ul></li><li><p><span>空间：</span></p><ul><li><p><span>ArrayList 内存连续，节省内存</span></p></li><li><p><span>LinkedList 需要存储数据和两个指针，更占内存</span></p></li></ul></li></ol><h4 id='5225-arraylist-和-linkedlist-不是线程安全的如何解决'><span>5.2.2.5 ArrayList 和 LinkedList 不是线程安全的，如何解决？</span></h4><p><span>ArrayList 和 LinkedList 都不是线程安全的。如果需要保证线程安全，有两种方案：</span></p><ol start='' ><li><p><span>使用线程安全的 </span><code>CopyOnWriteArrayList</code><span> 和 </span><code>ConcurrentLinkedDeque</code></p></li><li><p><span>在方法内使用局部变量</span></p></li></ol><h3 id='523-hashmap-相关'><span>5.2.3 HashMap 相关</span></h3><h4 id='5231-hashmap-的底层原理'><span>5.2.3.1 HashMap 的底层原理？</span></h4><ol start='' ><li><p><span>底层使用 </span><strong><span>hash 表</span></strong><span> 数据结构，即：</span></p><ul><li><p><span>JDK1.7 采用拉链法，采用数组+链表。</span></p></li><li><p><span>JDK1.8 进行了优化，采用数组+链表或红黑树。链表长度 &gt; 8 且数组长度 &gt; 64 则链表转化为红黑树。</span></p></li></ul></li><li><p><span>通过 </span><code>hash(key)</code><span> 计算 </span><strong><span>数组下标</span></strong><span>，进行存取元素。</span></p><ul><li><p><span>如果 哈希冲突，则进行判断：如果 key 相同则覆盖，如果 key 不同则存入桶中。</span></p></li></ul></li><li><p><span>如果 </span><strong><span>多个线程</span></strong><span> 同时对 </span><code>HashMap</code><span> 进行修改操作，可能会导致数据结构破坏，进而引发各种问题，比如丢失数据等。</span></p></li></ol><h4 id='5233-hashmap-的-put-方法的具体流程'><span>5.2.3.3 HashMap 的 put 方法的具体流程？</span></h4><ol start='' ><li><p><span>如果数组为空或 null，则执行 </span><code>resize()</code><span> 初始化。</span></p></li><li><p><span>根据 </span><code>hash(key)</code><span> 得到数组下标 i：</span></p><ul><li><p><span>如果 table[i] 为 null，则直接添加。</span></p></li><li><p><span>如果 table[i] 不为 null：如果 key 相同则覆盖，否则则存入链表或红黑树中。</span></p></li></ul></li><li><p><span>如果 put 后大小超过了 </span><code>数组长度*0.75</code><span>，则执行 </span><code>resize()</code><span> 扩容。 </span></p></li></ol><h4 id='5234-hashmap-的扩容机制'><span>5.2.3.4 HashMap 的扩容机制？</span></h4><ol start='' ><li><p><span>如果数组为空或 null，则执行 </span><code>resize()</code><span> 初始化大小为 16。</span></p></li><li><p><span>如果 put 后大小超过了 </span><code>数组长度*0.75</code><span>，则执行 </span><code>resize()</code><span> 扩容为 2 倍。 </span></p></li><li><p><span>扩容会新建一个数组，把老数组中的数据挪动到新的数组中。</span></p></li></ol><h4 id='5235-hashmap-的寻址算法'><span>5.2.3.5 HashMap 的寻址算法？</span></h4><p><strong><span>hashMap 的寻址算法？</span></strong></p><ol start='' ><li><p><span>计算对象的 </span><code>hashCode()</code><span>，再调用 </span><code>hash()</code><span> 二次哈希。</span></p></li><li><p><code>hashcode</code><span> 值右移 16 位与其异或运算，让哈希分布更为均匀。</span></p></li><li><p><span>最后 </span><code>hash &amp; (capacity – 1)</code><span>，即取模得到数组下标。</span></p></li></ol><p><strong><span>为何 HashMap 的数组长度一定是 2 的次幂？</span></strong></p><ul><li><p><span>这样可以使用位与运算 </span><code>hash &amp; (capacity – 1)</code><span> 代替取模，效率更高。</span></p></li><li><p><span>扩容时重新计算下标 </span><code>hash &amp; oldCap == 0</code><span> 的元素留在原来位置 ，效率更高。</span></p></li></ul><h4 id='5236-hashmap-在-jdk17-下的多线程死循环问题'><span>5.2.3.6 Hashmap 在 JDK1.7 下的多线程死循环问题？</span></h4><p><span>Hashmap 在 JDK1.7 下数组进行扩容的时候，因为链表是头插法，在进行数据迁移的过程中可能导致死循环。比如：</span></p><ol start='' ><li><p><span>线程一：读取 hashmap 数据，数据中一个链表，在准备扩容时线程二介入了。</span></p></li><li><p><span>线程二：也读取 hashmap 数据，直接扩容。因为是头插法，链表的顺序会颠倒。比如原来是 AB，扩容后是 BA。</span></p></li><li><p><span>线程一：继续扩容的时候就会出现死循环的问题。</span></p></li></ol><ul><li><p><span>分析：线程一先将 A 移入新链表，再将 B 插入到链头，由于线程二的原因 B-&gt;A，所以 B-&gt;A-&gt;B 形成循环。</span></p></li></ul><p><span>JDK1.8 将扩容算法做了调整，不再使用头插法而是尾插法，避免了死循环的问题。</span></p><h4 id='5237-concurrenthashmap-的底层原理'><span>5.2.3.7 ConcurrentHashMap 的底层原理？</span></h4><ol start='' ><li><p><span>JDK1.7 采用 </span><strong><code>Segment</code><span> 分段锁</span></strong><span>，通过将哈希表分为多个段来减少 </span><strong><span>锁竞争</span></strong><span>，提高并发性能。</span></p></li><li><p><span>JDK1.8 移除 </span><code>Segment</code><span> 分段锁，采用了 </span><strong><code>synchronized</code><span> 锁</span></strong><span> 和 </span><strong><span>CAS 操作</span></strong><span>，简化了锁管理。</span></p></li></ol><p>&nbsp;</p><h1 id='第-6-章---juc-篇'><span>第 6 章 - JUC 篇</span></h1><h2 id='61-线程基础'><span>6.1 线程基础</span></h2><h3 id='611-线程与进程的区别'><span>6.1.1 线程与进程的区别？</span></h3><ul><li><p><span>进程是正在运行程序的 </span><strong><span>实例</span></strong><span>，进程中包含了线程，每个线程执行不同的 </span><strong><span>任务</span></strong><span>。</span></p></li><li><p><span>不同的进程使用 </span><strong><span>不同</span></strong><span> 的内存空间，在当前进程下的所有线程可以 </span><strong><span>共享</span></strong><span> 内存空间。</span></p></li><li><p><span>线程更 </span><strong><span>轻量</span></strong><span>，线程上下文切换成本一般上要比进程上下文切换低。</span></p></li></ul><p><img src="baguwen\8071340.png" alt="8071340" style="zoom: 67%;" /></p><h3 id='612-并行与并发的区别'><span>6.1.2 并行与并发的区别？</span></h3><ul><li><p><span>并发是同一时间应对多件事情的能力，比如：多个线程 </span><strong><span>轮流</span></strong><span> 使用多个 CPU。</span></p></li><li><p><span>并行是同一时间动手做多件事情的能力，比如：4 核 CPU </span><strong><span>同时</span></strong><span> 执行 4 个线程。</span></p></li></ul><h3 id='613-线程创建的方式有哪些'><span>6.1.3 线程创建的方式有哪些？</span></h3><ol start='' ><li><p><span>继承 </span><strong><span>Thread</span></strong><span> 类</span></p></li><li><p><span>实现 </span><strong><span>Runnable</span></strong><span> 接口</span></p></li><li><p><span>实现 </span><strong><span>Callable</span></strong><span> 接口</span></p></li><li><p><span>线程池 </span><strong><span>ThreadPoolExecutor</span></strong><span> 创建线程</span></p></li></ol><h3 id='614-runnable-和-callable-有什么区别'><span>6.1.4 Runnable 和 Callable 有什么区别？</span></h3><ul><li><p><span>Runnable 接口 </span><code>run</code><span> 方法没有返回值。且异常只能在内部消化，不允许抛出异常。</span></p></li><li><p><span>Callable 接口 </span><code>call</code><span> 方法有返回值，需要 </span><code>FutureTask</code><span> 获取结果。且允许抛出异常。</span></p></li></ul><h3 id='615-线程的-run-和-start-有什么区别'><span>6.1.5 线程的 run() 和 start() 有什么区别？</span></h3><ul><li><p><code>start()</code><span>：只能被调用一次，用来启动线程。</span></p></li><li><p><code>run()</code><span>：可以被调用多次，用来执行封装的代码。</span></p></li></ul><h3 id='616-线程包括哪些状态状态之间是如何变化的'><span>6.1.6 线程包括哪些状态，状态之间是如何变化的？</span></h3><ol start='' ><li><p><span>创建线程对象是 </span><strong><span>新建</span></strong><span> 状态。</span></p></li><li><p><span>调用 start 方法变为 </span><strong><span>可执行</span></strong><span> 状态。</span></p></li><li><p><span>如果获取到了 CPU 的执行权，执行结束是 </span><strong><span>终止</span></strong><span> 状态。否则：</span></p><ul><li><p><span>如果没有获取锁 synchronized 或 lock 进入 </span><strong><span>阻塞</span></strong><span> 状态，获得锁再变为可执行状态。</span></p></li><li><p><span>如果调用 wait 方法进入 </span><strong><span>等待</span></strong><span> 状态，调用 notify 方法再变为可执行状态。</span></p></li><li><p><span>如果调用 sleep 方法进入 </span><strong><span>计时等待</span></strong><span> 状态，到时间后再变为可执行状态。</span></p></li></ul></li></ol><h3 id='617-wait-和-sleep-方法的不同'><span>6.1.7 wait 和 sleep 方法的不同？</span></h3><ul><li><p><span>wait 的调用必须获取 </span><strong><span>对象锁</span></strong><span>，而 sleep 则不用。</span></p></li><li><p><span>wait 是 Object 的成员方法，执行后 </span><strong><span>会释放</span></strong><span> 对象锁（其他人可以用）。</span></p></li><li><p><span>sleep 是 Thread 的静态方法，执行后 </span><strong><span>不会释放</span></strong><span> 对象锁（其他人也用不了）。</span></p></li></ul><h3 id='618-新建三个线程如何保证它们按顺序执行'><span>6.1.8 新建三个线程，如何保证它们按顺序执行？</span></h3><p><span>可以使用线程中的 </span><code>join</code><span> 方法解决。</span></p><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="java"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="java"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Thread</span> <span class="cm-variable">t1</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Thread</span>( () <span class="cm-operator">-&gt;</span> {} );</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Thread</span> <span class="cm-variable">t2</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Thread</span>( () <span class="cm-operator">-&gt;</span> {<span class="cm-variable">t1</span>.<span class="cm-variable">join</span>();} );<span class="cm-tab" role="presentation" cm-text="	">   </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 等待 t1 运行结束</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-variable">Thread</span> <span class="cm-variable">t3</span> <span class="cm-operator">=</span> <span class="cm-keyword">new</span> <span class="cm-variable">Thread</span>( () <span class="cm-operator">-&gt;</span> {<span class="cm-variable">t2</span>.<span class="cm-variable">join</span>();} );<span class="cm-tab" role="presentation" cm-text="	">   </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment">// 等待 t2 运行结束</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;"></div><div class="CodeMirror-gutters" style="display: none; height: 69px;"></div></div></div></pre><h3 id='619-notify-和-notifyall-有什么区别'><span>6.1.9 notify() 和 notifyAll() 有什么区别？</span></h3><ul><li><p><code>notifyAll</code><span>：唤醒所有 wait 的线程</span></p></li><li><p><code>notify</code><span>：随机唤醒一个 wait 线程</span></p></li></ul><h3 id='6110-如何停止一个正在运行的线程'><span>6.1.10 如何停止一个正在运行的线程？</span></h3><ol start='' ><li><p><span>使用 退出标志，当 run 方法完成后线程终止。</span></p></li><li><p><span>使用 </span><code>stop</code><span> 方法强行终止（不推荐，方法已作废）。</span></p></li><li><p><span>使用 </span><code>interrupt</code><span> 方法中断线程：</span></p><ul><li><p><span>打断阻塞线程的线程（wait，sleep，join ），会抛出 </span><code>InterruptedException</code><span> 异常。</span></p></li><li><p><span>打断正常的线程，可以根据打断状态来标记是否退出线程。</span></p></li></ul></li></ol><h2 id='62-线程安全'><span>6.2 线程安全</span></h2><h3 id='621-synchronized-关键字的底层原理'><span>6.2.1 synchronized 关键字的底层原理？</span></h3><ol start='' ><li><p><span>Synchronized 对象锁采用 </span><strong><span>互斥</span></strong><span> 的方式，让同一时刻至多只有一个线程能持有对象锁。</span></p></li><li><p><span>它的底层由 </span><strong><span>monitor</span></strong><span> 实现，monitor 是 JVM 级别的对象（ C++实现），内部有三个属性：</span></p><ul><li><p><code>owner</code><span> 关联的是当前获得锁的线程</span></p></li><li><p><code>entrylist</code><span> 关联的是处于阻塞状态的线程队列</span></p></li><li><p><code>waitset</code><span> 关联的是处于等待状态的线程队列</span></p></li></ul></li></ol><p><strong><span>Monitor 实现的锁属于重量级锁，你了解过锁升级吗？</span></strong></p><p><span>Synchronized 有重量级锁、轻量级锁、偏向锁三种形式，分别对应锁被多线程竞争持有、多线程交替持有、一线程单独持有的情况。</span></p><figure class='table-figure'><table><thead><tr><th>&nbsp;</th><th><strong><span>描述</span></strong></th></tr></thead><tbody><tr><td><span>重量级锁</span></td><td><span>底层使用 Monitor 实现，里面涉及到了 </span><strong><span>用户态和内核态的切换</span></strong><span>、进程的上下文切换，成本较高，性能比较低。</span></td></tr><tr><td><span>轻量级锁</span></td><td><span>轻量级修改了对象头的锁标志，相比重量级锁性能提升很多。每次修改都是 </span><strong><code>CAS</code><span> 操作</span></strong><span>，保证原子性。</span></td></tr><tr><td><span>偏向锁</span></td><td><span>线程第一次获得锁时会有一个 </span><code>CAS</code><span> 操作，之后再获取锁只判断 </span><strong><code>mark word</code></strong><span> 中的线程 id 即可。</span></td></tr></tbody></table></figure><h3 id='622-谈谈-jmmjava-内存模型）'><span>6.2.2 谈谈 JMM（Java 内存模型）？</span></h3><ul><li><p><span>JMM 定义了共享内存中多线程程序读写操作的行为规范，从而保证指令的正确性。</span></p></li><li><p><span>JMM 把内存分为了两块，一块是私有线程的工作区域（</span><strong><span>工作内存</span></strong><span>），一块是所有线程的共享区域（</span><strong><span>主内存</span></strong><span>）。</span></p></li><li><p><span>线程之间是相互隔离的，线程交互需要通过主内存。</span></p></li></ul><h3 id='623-谈谈-cas'><span>6.2.3 谈谈 CAS？</span></h3><ul><li><p><span>CAS（Compare And Swap，比较再交换）体现了一种 </span><strong><span>乐观锁</span></strong><span> 的思想，在无锁状态下保证线程操作的原子性。</span></p></li><li><p><span>在操作共享变量的时候使用 </span><strong><span>自旋锁</span></strong><span>，效率上更高一些。</span></p></li><li><p><span>CAS 的底层调用 </span><strong><span>Unsafe</span></strong><span> 类中的方法，都是操作系统提供的（c++ 实现）。</span></p></li></ul><p><strong><span>乐观锁和悲观锁的区别？</span></strong></p><ol start='' ><li><p><code>CAS</code><span>  基于乐观锁的思想：不怕其它线程来修改共享变量，就算改了也没关系。</span></p></li><li><p><code>synchronized</code><span>  基于悲观锁的思想：防着其它线程来修改共享变量，我上了锁你们都别想改。</span></p></li></ol><h3 id='624-谈谈-aqs'><span>6.2.4 谈谈 AQS？</span></h3><p><span>AQS（Abstract Queued Synchronizer）是多线程中的 </span><strong><span>队列同步器</span></strong><span>，是一种锁的机制。</span></p><ol start='' ><li><p><span>AQS 内部有一个先进先出的 </span><strong><span>双向队列</span></strong><span>，用来存储排队的线程。</span></p></li><li><p><span>AQS 内部有一个属性 </span><strong><span>state</span></strong><span>，如果队列中有线程被修改，则通过 CAS 操作置为 1 表示获取了资源。</span></p></li></ol><h3 id='625-reentrantlock-的实现原理'><span>6.2.5 ReentrantLock 的实现原理？</span></h3><p><span>ReentrantLock 表示支持 </span><strong><span>重入</span></strong><span> 的锁，调用方法获取锁之后，再次调用不会被阻塞。</span></p><ul><li><p><span>ReentrantLock 主要利用 CAS + AQS 队列来实现。</span></p></li><li><p><span>支持公平锁和非公平锁，在构造器中无参默认是非公平锁，也可以传参为公平锁。</span></p></li></ul><h3 id='626-synchronized-和-lock-的区别'><span>6.2.6 synchronized 和 Lock 的区别？</span></h3><ul><li><p><span>语法层面</span></p><ul><li><p><span>synchronized 是 </span><strong><span>关键字</span></strong><span>，源码在 jvm 中，用 c++ 语言实现。自动释放锁。</span></p></li><li><p><span>Lock 是 </span><strong><span>接口</span></strong><span>，源码由 jdk 提供，用 java 语言实现。手动释放锁。</span></p></li></ul></li><li><p><span>功能层面</span></p><ul><li><p><span>Lock 提供了 synchronized 不具备的功能，例如公平锁、可打断、可超时、多条件变量。</span></p></li><li><p><span>Lock 有适合不同场景的实现，如 </span><code>ReentrantLock</code><span>， </span><code>ReentrantReadWriteLock</code><span>（读写锁）。</span></p></li></ul></li><li><p><span>性能层面</span></p><ul><li><p><span>在没有竞争时，synchronized 的性能一般，但轻量级锁、偏向锁也不赖。</span></p></li><li><p><span>在竞争激烈时，Lock 的性能更好。</span></p></li></ul></li></ul><h3 id='627-死锁产生的条件'><span>6.2.7 死锁产生的条件？</span></h3><p><span>一个线程需要同时获取多把锁，这时就容易发生死锁。</span></p><h3 id='628-如何进行死锁诊断'><span>6.2.8 如何进行死锁诊断？</span></h3><ol start='' ><li><p><code>jps</code><span>：jdk 自带工具，检查进程的状态信息。</span></p></li><li><p><code>jstack</code><span>：jdk 自带工具，检查线程的堆栈信息，查看日志。</span></p></li><li><p><code>jconsole</code><span>、</span><code>VisualVM</code><span>：可视化工具，也可以检查死锁问题。</span></p></li></ol><h3 id='629-请谈谈你对-volatile-的理解'><span>6.2.9 请谈谈你对 volatile 的理解？</span></h3><ol start='' ><li><p><span>保证线程间的可见性。用 volatile 修饰共享变量，能够防止编译器的优化，让一个线程对共享变量的修改对另一个线程可见。</span></p></li><li><p><span>禁止进行指令重排序。用 volatile 修饰共享变量，会加入不同的屏障，阻止其他读写操作越过屏障。</span></p></li></ol><h3 id='6210-并发程序出现问题的根本原因'><span>6.2.10 并发程序出现问题的根本原因？</span></h3><ol start='' ><li><p><span>没有保证 </span><strong><span>原子性</span></strong><span>：一个线程在 CPU 中操作不可暂停，也不可中断。解决：</span><code>synchronized</code><span>、</span><code>lock</code><span>。</span></p></li><li><p><span>没有保证 </span><strong><span>可见性</span></strong><span>：让一个线程对共享变量的修改对另一个线程可见。解决：</span><code>volatile</code><span>、</span><code>synchronized</code><span>、</span><code>lock</code><span>。</span></p></li><li><p><span>没有保证 </span><strong><span>有序性</span></strong><span>。因为处理器为了提高运行效率，对代码进行了优化。解决：</span><code>volatile</code><span>。</span></p></li></ol><h2 id='63-线程池'><span>6.3 线程池</span></h2><h3 id='631-线程池的执行原理'><span>6.3.1 线程池的执行原理？</span></h3><ol start='' ><li><p><span>ThreadPoolExecutor 创建线程池的核心参数：</span></p><ul><li><p><code>corePoolSize</code><span>：核心线程数目</span></p></li><li><p><code>maximumPoolSize</code><span>：最大线程数目 = 核心线程数目 + 非核心线程数目</span></p></li><li><p><code>keepAliveTime</code><span>：生存时间，生存时间内没有新任务，此线程资源会释放</span></p></li><li><p><code>unit</code><span>：生存时间单位，如秒、毫秒等</span></p></li><li><p><code>workQueue</code><span>：阻塞队列，当没有空闲核心线程时，新来任务会加入到此队列排队</span></p></li><li><p><code>threadFactory</code><span>：线程工厂，可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</span></p></li><li><p><code>handler</code><span>：拒绝策略，当所有线程都在忙，阻塞队列也放满时，会触发拒绝策略</span></p></li></ul></li><li><p><span>线程池的执行原理：</span></p></li></ol><p><img src="baguwen\8071608.png" alt="8071608" style="zoom:48%;" /></p><h3 id='632-线程池中有哪些常见的阻塞队列'><span>6.3.2 线程池中有哪些常见的阻塞队列？</span></h3><figure class='table-figure'><table><thead><tr><th><strong><span>LinkedBlockingQueue</span></strong></th><th><strong><span>ArrayBlockingQueue</span></strong></th></tr></thead><tbody><tr><td><span>默认无界，支持有界</span></td><td><span>强制有界</span></td></tr><tr><td><span>底层是链表</span></td><td><span>底层是数组</span></td></tr><tr><td><span>是懒惰的，创建节点的时候添加数据</span></td><td><span>提前初始化 Node 数组</span></td></tr><tr><td><span>入队会创建新 Node</span></td><td><span>Node 需要提前创建好</span></td></tr><tr><td><span>两把锁（头尾）</span></td><td><span>一把锁</span></td></tr></tbody></table></figure><h3 id='633-如何确定核心线程数'><span>6.3.3 如何确定核心线程数？</span></h3><ol start='' ><li><p><span>高并发、任务执行时间短：</span><code>CPU 核数 + 1</code><span>，减少线程上下文的切换。</span></p></li><li><p><span>并发不高、任务执行时间长：</span></p><ul><li><p><span>IO 密集型的任务：</span><code>CPU核数 * 2 + 1</code><span>。</span></p></li><li><p><span>计算密集型任务：</span><code>CPU核数 + 1</code><span>。</span></p></li></ul></li></ol><h3 id='634-线程池的种类有哪些'><span>6.3.4 线程池的种类有哪些？</span></h3><ol start='' ><li><p><code>newFixedThreadPool</code><span>：</span><strong><span>定长 </span></strong><span>的线程池，可控制线程最大并发数，超出的线程会在队列中等待。</span></p></li><li><p><code>newSingleThreadExecutor</code><span>：</span><strong><span>单线程 </span></strong><span>化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按 FIFO 顺序执行。</span></p></li><li><p><code>newCachedThreadPool</code><span>：</span><strong><span>可缓存</span></strong><span> 的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</span></p></li><li><p><code>newScheduledThreadPool</code><span>：可执行 </span><strong><span>延迟任务</span></strong><span> 的线程池，支持定时及周期性任务执行。</span></p></li></ol><h3 id='635-为什么不建议用-executors-创建线程池'><span>6.3.5 为什么不建议用 Executors 创建线程池？</span></h3><p><span>线程池不建议使用 Executors 创建，而是通过 ThreadPoolExecutor，可以规避资源耗尽的风险。分析源码：</span></p><ol start='' ><li><p><span>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 </span><code>Integer.MAXVALUE</code><span>，可能堆积 </span><strong><span>大量请求</span></strong><span>，从而导致 OOM。</span></p></li><li><p><span>CachedThreadPool：允许的创建线程数量为 </span><code>Integer.MAXVALUE</code><span>，可能创建 </span><strong><span>大量线程</span></strong><span>，从而导致 OOM。</span></p></li></ol><h2 id='64-使用场景'><span>6.4 使用场景</span></h2><h3 id='641-线程池使用场景你的项目中哪里用到了）'><span>6.4.1 线程池使用场景（你的项目中哪里用到了）？</span></h3><ul><li><p><span>批量导入：使用了线程池 + CountDownLatch 批量把数据库中的数据导入到了 ES 中，避免 OOM。</span></p></li><li><p><span>数据汇总：调用多个接口来汇总数据，如果部分接口没有依赖关系，就可以使用线程池 + future 来提升性能。</span></p></li><li><p><span>异步线程：为了避免下一级方法影响上一级方法，使用异步线程调用下一个方法（不需要下一级方法返回值），提升响应时间。</span></p></li></ul><h3 id='642-如何控制某个方法允许并发访问线程的数量'><span>6.4.2 如何控制某个方法允许并发访问线程的数量？</span></h3><p><span>在多线程中提供了一个工具类 Semaphore，信号量。在并发的情况下，可以控制方法的访问量：</span></p><ol start='' ><li><p><span>创建 </span><code>Semaphore</code><span> 对象，可以给一个容量。</span></p></li><li><p><code>acquire()</code><span> 可以请求一个信号量，此时信号量个数 - 1。</span></p></li><li><p><code>release()</code><span> 可以释放一个信号量，此时信号量个数 + 1。</span></p></li></ol><h3 id='643-谈谈-threadlocal'><span>6.4.3 谈谈 ThreadLocal？</span></h3><ol start='' ><li><p><code>ThreadLocal</code><span> 实现了资源对象的 </span><strong><span>线程隔离</span></strong><span>，让每个线程各用各的，</span><strong><span>避免争用</span></strong><span> 引发线程安全问题。</span></p></li><li><p><code>ThreadLocal</code><span> 实现了线程内的 </span><strong><span>资源共享</span></strong><span>。每个线程内有一个 </span><code>ThreadLocalMap</code><span> 类型的成员变量：</span></p><ul><li><p><span>调用 </span><code>set</code><span> 方法，以 ThreadLocal 作为 key，以资源对象作为 value 存入。</span></p></li><li><p><span>调用 </span><code>get</code><span> 方法，以 ThreadLocal 作为 key，以资源对象作为 value 取出。</span></p></li></ul></li><li><p><strong><span>内存泄漏</span></strong><span> 问题：key 是弱引用，会被 GC 释放内存。而 value 是强引用，不会释放。建议主动调用 </span><code>remove</code><span> 释放。</span></p></li></ol><p>&nbsp;</p><h1 id='第-7-章---jvm-篇'><span>第 7 章 - JVM 篇</span></h1><h2 id='71-jvm-组成'><span>7.1 JVM 组成</span></h2><p><img src="baguwen\8092110.png" alt="8092110" style="zoom: 67%;" /></p><h3 id='711-什么是程序计数器'><span>7.1.1 什么是程序计数器？</span></h3><p><span>线程私有的，每个线程一份，内部保存字节码的行号。用于记录正在执行的 </span><strong><span>字节码指令</span></strong><span> 的 </span><strong><span>地址</span></strong><span>。</span></p><h3 id='712-介绍一下堆'><span>7.1.2 介绍一下堆？</span></h3><ul><li><p><span>堆主要用来保存对象实例，数组等，内存不够则抛出 </span><code>OutOfMemoryError</code><span> 异常。</span></p></li><li><p><span>组成：年轻代 + 老年代</span></p><ul><li><p><strong><span>年轻代</span></strong><span> 被划分为三部分，Eden 区和两个大小相同的 Survivor 区</span></p></li><li><p><strong><span>老年代</span></strong><span> 主要保存生命周期长的对象，一般是一些老的对象</span></p></li></ul></li><li><p><span>jdk1.7 和 1.8 的区别：</span></p><ul><li><p><span>1.7 中有一个永久代，存储的是类信息、静态变量、常量、编译后的代码</span></p></li><li><p><span>1.8 移除了永久代，把数据存储到了本地内存的元空间中，防止内存溢出</span></p></li></ul></li></ul><h3 id='713-什么是虚拟机栈'><span>7.1.3 什么是虚拟机栈？</span></h3><ul><li><p><span>每个线程运行时所需要的 </span><strong><span>内存</span></strong><span>，称为虚拟机栈。</span></p></li><li><p><span>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存。</span></p></li><li><p><span>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</span></p></li></ul><h3 id='714-垃圾回收是否涉及栈内存'><span>7.1.4 垃圾回收是否涉及栈内存？</span></h3><p><span>否，垃圾回收主要指堆内存。因为当栈帧弹栈以后，内存会自己释放。</span></p><h3 id='715-栈内存分配越大越好吗'><span>7.1.5 栈内存分配越大越好吗？</span></h3><p><span>否，默认的栈内存通常为 1024k，栈帧过大会导致线程数变少。</span></p><h3 id='716-方法内的局部变量是否线程安全'><span>7.1.6 方法内的局部变量是否线程安全？</span></h3><ul><li><p><span>如果方法内局部变量没有逃离方法的作用范围，则它是线程安全的。</span></p></li><li><p><span>如果方法内局部变量逃离了方法的作用范围，则它不是线程安全的。</span></p></li></ul><h3 id='717-什么情况下会导致栈内存溢出'><span>7.1.7 什么情况下会导致栈内存溢出？</span></h3><ul><li><p><span>栈帧过多会导致栈内存溢出，比如递归调用。</span></p></li><li><p><span>栈帧过大会导致栈内存溢出。</span></p></li></ul><h3 id='718-堆和栈的区别'><span>7.1.8 堆和栈的区别？</span></h3><ol start='' ><li><p><span>栈内存用来存储 </span><strong><span>局部变量</span></strong><span> 和 方法调用，而堆内存用来存储 </span><strong><span>对象</span></strong><span> 和 数组。</span></p></li><li><p><span>栈内存是线程 </span><strong><span>私有的</span></strong><span>，而堆内存是线程 </span><strong><span>共有的</span></strong><span>。</span></p></li><li><p><span>栈不会垃圾回收，而堆会 </span><strong><span>垃圾回收</span></strong><span>。</span></p></li><li><p><span>栈空间不足抛异常 </span><code>StackOverFlowError</code><span>，而堆空间不足抛异常 </span><code>OutOfMemoryError</code><span>。</span></p></li></ol><h3 id='719-介绍一下方法区'><span>7.1.9 介绍一下方法区？</span></h3><ul><li><p><span>方法区是各个线程共享的内存区域，主要存储 </span><strong><span>类的信息</span></strong><span>、</span><strong><span>运行时常量池</span></strong><span>。</span></p></li><li><p><span>虚拟机启动时创建，虚拟机关闭时释放。</span></p></li><li><p><span>方法区空间不足抛异常 </span><code>OutOfMemoryError: Metaspace</code><span>。</span></p></li></ul><p><strong><span>介绍一下运行时常量池？</span></strong></p><ul><li><p><span>常量池可以看作是一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等信息。</span></p></li><li><p><span>当类被加载时，常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。</span></p></li></ul><h3 id='7111-介绍一下直接内存'><span>7.1.11 介绍一下直接内存？</span></h3><ul><li><p><span>直接内存不属于 JVM 内存结构，它是虚拟机的 </span><strong><span>系统内存</span></strong><span>。</span></p></li><li><p><span>常见于 NIO 操作，用于数据缓冲区。分配回收成本较高，但 </span><strong><span>读写性能高</span></strong><span>，不受 JVM 内存回收管理。</span></p></li></ul><h2 id='72-类加载器'><span>7.2 类加载器</span></h2><h3 id='721-什么是类加载器类加载器有哪些'><span>7.2.1 什么是类加载器，类加载器有哪些？</span></h3><p><span>JVM 只会运行 </span><strong><span>二进制</span></strong><span> 文件，类加载器的作用是将 </span><strong><span>字节码</span></strong><span> 文件加载到 JVM 中，从而让 Java 程序能够启动起来。</span></p><ol start='' ><li><p><span>启动类加载器（</span><code>BootStrap ClassLoader</code><span>）：加载 JAVA_HOME/jre/lib 目录下的库。</span></p></li><li><p><span>扩展类加载器（</span><code>ExtClassLoader</code><span>）：加载 JAVA_HOME/jre/lib/ext 目录中的类。</span></p></li><li><p><span>应用类加载器（</span><code>AppClassLoader</code><span>）：加载 classPath下的类。</span></p></li><li><p><span>自定义加载器（</span><code>CustomizeClassLoader</code><span>）：自定义类继承 ClassLoader，实现自定义加载规则。</span></p></li></ol><h3 id='722-什么是双亲委派模型'><span>7.2.2 什么是双亲委派模型？</span></h3><ul><li><p><span>加载某一个类，先委托上级加载器进行加载，如果上级加载器也有上级，则会继续向上委托。</span></p></li><li><p><span>如果委托上级没有被加载，则尝试子加载器加载该类。</span></p></li></ul><p><img src="baguwen\8071837.png" alt="8071837" style="zoom: 50%;" /></p><h3 id='723-jvm-为什么采用双亲委派机制'><span>7.2.3 JVM 为什么采用双亲委派机制？</span></h3><ul><li><p><span>可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。</span></p></li><li><p><span>为了安全，保证类库 API 不会被修改。</span></p></li></ul><h3 id='724-类装载的执行过程'><span>7.2.4 类装载的执行过程？</span></h3><ol start='' ><li><p><span>加载：查找和导入 class 文件。</span></p></li><li><p><span>验证：保证加载类的准确性。</span></p></li><li><p><span>准备：为类变量分配内存并设置类变量初始值。</span></p></li><li><p><span>解析：把类中的符号引用转换为直接引用。</span></p></li><li><p><span>初始化：对类的静态变量，静态代码块执行初始化操作。</span></p></li><li><p><span>使用：JVM 开始从入口方法开始执行用户的程序代码。</span></p></li><li><p><span>卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象。</span></p></li></ol><h2 id='73-垃圾回收'><span>7.3 垃圾回收</span></h2><h3 id='731-对象什么时候可以被垃圾器回收'><span>7.3.1 对象什么时候可以被垃圾器回收？</span></h3><ul><li><p><span>如果一个或多个对象没有任何的 </span><strong><span>引用</span></strong><span> 指向它了，则变成垃圾，可能会被垃圾回收器回收。</span></p></li></ul><ul><li><p><span>定位垃圾的方式有两种：① 引用计数法；② 可达性分析算法。</span></p></li></ul><h3 id='732-说一下强引用软引用弱引用虚对象'><span>7.3.2 说一下强引用、软引用、弱引用、虚对象？</span></h3><ol start='' ><li><p><span>强引用：只要所有 </span><code>GC Roots</code><span> 能找到，就不会被回收引用对象。</span></p></li><li><p><span>软引用：配合 </span><code>SoftReference</code><span> 使用，当多次垃圾回收内存依然不够时，就会回收引用对象。</span></p></li><li><p><span>弱引用：配合 </span><code>WeakReference</code><span> 使用，只要垃圾回收，就会回收引用对象。</span></p></li><li><p><span>虚引用：配合 </span><code>引用队列</code><span> 使用，被引用对象回收时会将虚引用入队，由 Reference Handler 线程调用虚引用方法释放直接内存。</span></p></li></ol><h3 id='733-jvm-垃圾回收算法有哪些'><span>7.3.3 JVM 垃圾回收算法有哪些？</span></h3><ol start='' ><li><p><strong><span>标记清除算法</span></strong><span>：标记需要清除的垃圾，直接清除。效率高，有磁盘碎片，内存不连续。</span></p></li><li><p><strong><span>标记整理算法</span></strong><span>：将存活对象向内存另一端移动，清除边界以外的垃圾。无碎片，对象需要移动，效率低。</span></p></li><li><p><strong><span>复制算法</span></strong><span>：将内存一分为二，每次只用一块。将正在使用的复制到另一个，清空后交换。无碎片，内存使用率低。</span></p></li></ol><h3 id='734-说一下-jvm-中的分代回收'><span>7.3.4 说一下 JVM 中的分代回收？</span></h3><ul><li><p><span>堆的区域划分：</span></p><ul><li><p><span>堆分为了两份：新生代、老年代，比例 1：2。</span></p></li><li><p><span>新生代分为了三份：</span><strong><span>eden 区</span></strong><span>、</span><strong><span>存活区 from</span></strong><span>、</span><strong><span>存活区 to</span></strong><span>，比例 8：1：1。</span></p></li></ul></li><li><p><span>分代回收策略：</span></p><ol start='' ><li><p><span>新创建的对象，都会先分配到 eden 区。</span></p></li><li><p><span>一段时间后 eden 内存不足，标记 eden 和 from 的存活对象。将其复制到 to，于是 eden 和 from 内存得到释放。</span></p></li><li><p><span>一段时间后 eden 内存又不足，标记 eden 和 to 的存活对象。将其复制到 from，于是 eden 和 to 内存得到释放。</span></p></li><li><p><span>当新生代如此往复几次（最多 15 次）后，晋升为老年代。</span></p></li></ol></li></ul><p><strong><span>MinorGC、 Mixed GC 、 FullGC 的区别是什么？</span></strong></p><ul><li><p><span>Minor GC：新生代的垃圾回收，暂停时间短。</span></p></li><li><p><span>Mixed GC：新生代 + 老年代部分的垃圾回收，G1 收集器特有。</span></p></li><li><p><span>Full GC：新生代 + 老年代完整的垃圾回收，暂停时间长，尽力避免。</span></p></li></ul><h3 id='735-说一下-jvm-有哪些垃圾回收器'><span>7.3.5 说一下 JVM 有哪些垃圾回收器？</span></h3><ol start='' ><li><p><span>串行垃圾回收器：Serial GC、Serial Old GC。</span></p></li><li><p><span>并行垃圾回收器：Parallel Old GC、ParNew GC。</span></p></li><li><p><span>并发垃圾回收器：CMS GC，作用在老年代。</span></p></li><li><p><span>G1 垃圾回收器，作用在新生代 + 老年代。</span></p></li></ol><h3 id='736-详细聊一下-g1-垃圾回收器'><span>7.3.6 详细聊一下 G1 垃圾回收器？</span></h3><p><span>G1 垃圾回收器，作用在新生代 + 老年代，在 JDK9 之后默认使用。</span></p><ul><li><p><span>划分成多个区域，每个区域都可以充当 eden，survivor，old， humongous（专为大对象准备）</span></p></li><li><p><span>采用复制算法。</span></p></li><li><p><span>响应时间与吞吐量兼顾。</span></p></li><li><p><span>分成三个阶段：① 新生代回收、② 并发标记、③ 混合回收。</span></p></li><li><p><span>如果并发失败（回收速度赶不上创建新对象速度），会触发 Full GC。</span></p></li></ul><h2 id='74-jvm-实践'><span>7.4 JVM 实践</span></h2><h3 id='741-jvm-调优的参数可以在哪里设置'><span>7.4.1 JVM 调优的参数可以在哪里设置？</span></h3><ul><li><p><span>war 包部署，在 tomcat 中设置：修改 T</span><code>OMCAT_HOME/bin/catalina.sh</code><span> 文件</span></p></li><li><p><span>jar 包部署，在启动参数设置：</span><code>java -Xms512m -Xmx1024m -jar xxxx.jar</code></p></li></ul><h3 id='742-jvm-调优的参数都有哪些'><span>7.4.2 JVM 调优的参数都有哪些？</span></h3><ul><li><p><span>设置堆空间大小</span></p></li><li><p><span>虚拟机栈的设置</span></p></li><li><p><span>年轻代中 Eden 区和两个 Survivor 区的大小比例</span></p></li><li><p><span>年轻代晋升老年代阈值</span></p></li><li><p><span>设置垃圾回收器</span></p></li></ul><h3 id='743-jvm-调优的工具'><span>7.4.3 JVM 调优的工具？</span></h3><ul><li><p><span>命令工具：</span></p><ol start='' ><li><p><code>jps</code><span>：进程状态信息</span></p></li><li><p><code>jstack</code><span>：查看进程内线程的堆栈信息</span></p></li><li><p><code>jmap</code><span>：查看堆转信息</span></p></li></ol></li><li><p><span>可视化工具：</span></p><ol start='' ><li><p><code>jconsole</code><span>：监控 jvm 的内存，线程，类的情况</span></p></li><li><p><code>VisualVM</code><span>：监控线程，内存情况</span></p></li></ol></li></ul><h3 id='744-java-内存泄露的排查思路'><span>7.4.4 Java 内存泄露的排查思路？</span></h3><p><span>内存泄漏通常是指堆内存，指一些大对象不被回收的情况。</span></p><ol start='' ><li><p><span>通过 </span><code>jmap</code><span> 或设置 jvm 参数获取堆内存快照 dump。</span></p></li><li><p><span>通过 </span><code>VisualVM</code><span> 加载 dump，查看堆信息的情况，定位是哪行代码出了问题。</span></p></li><li><p><span>通过阅读代码上下文的情况，进行修复即可。</span></p></li></ol><h3 id='745-cpu-飙高排查方案与思路'><span>7.4.5 CPU 飙高排查方案与思路？</span></h3><ol start='' ><li><p><span>通过 </span><code>top</code><span> 命令查看是哪一个进程占用 cpu 较高。</span></p></li><li><p><span>使用 </span><code>ps</code><span> 命令查看进程中的线程信息。</span></p></li><li><p><span>使用 </span><code>jstack</code><span> 命令查看进程中哪些线程出现了问题，最终定位问题。</span></p></li></ol><p>&nbsp;</p><h1 id='第-8-章---企业场景篇'><span>第 8 章 - 企业场景篇</span></h1><h2 id='81-设计模式'><span>8.1 设计模式</span></h2><h3 id='811-工厂方法模式'><span>8.1.1 工厂方法模式</span></h3><ol start='' ><li><p><span>简单工厂模式：</span></p><ul><li><p><span>所有的产品都共有一个工厂，如果新增产品，则需要修改代码，违反开闭原则。</span></p></li><li><p><span>这是一种编程习惯，可以借鉴这种编程思路。</span></p></li></ul></li><li><p><strong><span>工厂方法模式</span></strong><span>：</span></p><ul><li><p><span>适用于需要创建不同类型的对象但不希望客户端直接依赖于具体类的场景。关注于创建对象并将 </span><strong><span>对象</span></strong><span> 的创建过程封装起来。</span></p></li><li><p><span>例如：一个图形编辑器需要创建不同类型的 </span><strong><span>图形对象</span></strong><span>（圆形、矩形），可以使用工厂模式来创建这些对象。</span></p></li></ul></li><li><p><span>抽象工厂模式：</span></p><ul><li><p><span>如果有多个纬度的产品需要配合生产时，优先建议采用抽象工厂（工厂的工厂）。</span></p></li><li><p><span>一般的企业开发中用的较少。</span></p></li></ul></li></ol><h3 id='812-策略模式'><span>8.1.2 策略模式</span></h3><ol start='' ><li><p><strong><span>策略模式</span></strong><span>：</span></p><ul><li><p><span>适用于需要在运行时选择不同的算法或行为的场景。关注于动态地选择和切换 </span><strong><span>算法</span></strong><span> 或行为。</span></p></li><li><p><span>例如：一个文本编辑器需要支持多种 </span><strong><span>格式化策略</span></strong><span>（粗体、斜体），可以通过策略模式来实现。</span></p></li></ul></li><li><p><span>工厂方法 + 策略：</span></p><p><span>介绍业务：登录、支付、解析 excel、优惠等级等。</span></p><ul><li><p><span>提供了多种策略：让 spring 容器进行管理。</span></p></li><li><p><span>提供了一个工厂：准备策略对象，根据参数提供对象。</span></p></li></ul></li></ol><h3 id='813-责任链模式'><span>8.1.3 责任链模式</span></h3><ul><li><p><span>为了 </span><strong><span>避免</span></strong><span> 请求发送者与多个请求处理者 </span><strong><span>耦合</span></strong><span> 在一起，将所有处理者通过前一对象记住其下一个对象的引用而连成一条链。</span></p></li><li><p><span>当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</span></p></li></ul><p><img src="baguwen\8072141.png" alt="8072141" style="zoom: 50%;" /></p><h2 id='82-常见技术场景'><span>8.2 常见技术场景</span></h2><h3 id='821-单点登录这块怎么实现的'><span>8.2.1 单点登录这块怎么实现的？</span></h3><ul><li><p><span>介绍自己项目中涉及到的单点登录（Single Sign On，简称 SSO）</span></p></li><li><p><span>介绍单点登录的解决方案，以 JWT 为例：</span></p><ol start='' ><li><p><span>用户访问其他系统，会在网关判断 </span><code>token</code><span> 是否有效。</span></p></li><li><p><span>如果无效则会返回 </span><code>401</code><span>，前端跳转到登录页面。</span></p></li><li><p><span>用户登录发送请求，响应返回一个 </span><code>token</code><span>，浏览器保存到 </span><code>cookie</code><span>。</span></p></li><li><p><span>用户再访问其他服务时，需要携带 </span><code>token</code><span>，由网关统一验证后路由。</span></p></li></ol></li></ul><h3 id='822-权限认证是如何实现的'><span>8.2.2 权限认证是如何实现的？</span></h3><ul><li><p><span>考察后台管理系统的开发经验。</span></p></li></ul><ol start='' ><li><p><span>介绍 RBAC 权限模型 5 张表的关系：用户表、角色表、权限表、用户角色中间表、角色权限中间表。</span></p></li><li><p><span>介绍权限框架：</span><code>Spring security</code><span>。</span></p></li></ol><h3 id='823-上传数据的安全性怎么控制'><span>8.2.3 上传数据的安全性怎么控制？</span></h3><p><span>使用非对称加密（或对称加密），给前端 </span><strong><span>公钥</span></strong><span> 加密数据后传到后台，后台负责 </span><strong><span>私钥</span></strong><span> 解密后处理数据。</span></p><ul><li><p><span>文件很大建议采用对称加密，速度较快，但不能保存敏感信息。</span></p></li><li><p><span>文件较小建议采用非对称加密，安全性高，但速度较慢。</span></p></li></ul><h3 id='824-你的项目遇到了哪些棘手的问题'><span>8.2.4 你的项目遇到了哪些棘手的问题？</span></h3><p><img src="baguwen\8072154.png" alt="8072154" style="zoom:48%;" /></p><h3 id='825-你是怎么做压测性能测试）的'><span>8.2.5 你是怎么做压测（性能测试）的？</span></h3><p>&nbsp;</p><h3 id='826-你项目中日志怎么采集的'><span>8.2.6 你项目中日志怎么采集的？</span></h3><p><span>我们搭建了 ELK 日志采集系统。介绍 ELK 的三个组件：</span></p><ul><li><p><code>Elasticsearch</code><span> 是全文搜索分析引擎，可以对数据存储、搜索、分析</span></p></li><li><p><code>Logstash</code><span> 是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置</span></p></li><li><p><code>Kibana</code><span> 是一个数据分析和可视化平台，配合 Elasticsearch 对数据进行搜索，分析，图表化展示</span></p></li></ul><h3 id='827-查看日志的命令'><span>8.2.7 查看日志的命令？</span></h3><pre class="md-fences md-end-block ty-contain-cm modeLoaded" spellcheck="false" lang="bash"><div class="CodeMirror cm-s-inner cm-s-null-scroll CodeMirror-wrap" lang="bash"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 9.51875px; left: 8px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">tail <span class="cm-attribute">-f</span> xx.log<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># 实时监控日志的变化</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">tail <span class="cm-attribute">-n</span> <span class="cm-number">100</span> xx.log<span class="cm-tab" role="presentation" cm-text="	">  </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># 按照行号查询</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">cat</span> <span class="cm-attribute">-n</span> xx.log | <span class="cm-builtin">grep</span> <span class="cm-string">"debug"</span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-tab" role="presentation" cm-text="	">    </span><span class="cm-comment"># 按照关键字找日志的信息</span></span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 69px;"></div><div class="CodeMirror-gutters" style="display: none; height: 69px;"></div></div></div></pre><h3 id='828-怎么快速定位系统的瓶颈'><span>8.2.8 怎么快速定位系统的瓶颈？</span></h3><ol start='' ><li><p><span>压测（性能测试），项目上线之前测评系统的压力。</span></p></li><li><p><span>监控工具、链路追踪工具，项目上线之后监控。</span></p></li><li><p><span>线上诊断工具 Arthas（阿尔萨斯），项目上线之后监控、排查。</span></p></li></ol><h3 id='829-生产问题怎么排查'><span>8.2.9 生产问题怎么排查？</span></h3><p><span>已经上线的 bug 排查的思路：</span></p><ol start='' ><li><p><span>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题。</span></p></li><li><p><span>通常公司的生产环境是不允许远程 debug 的，一般都是远程 debug 公司的测试环境，方便调试代码。</span></p></li></ol><p>&nbsp;</p></div></div>
</body>
</html>